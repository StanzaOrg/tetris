defpackage tetris :
   import core
   import collections
   import qt5

;============================================================
;====================== Tile ================================
;============================================================

deftype Tile
defmulti cols (t:Tile) -> Int
defmulti rows (t:Tile) -> Int
defmulti dots (t:Tile) -> Collection<[Int, Int, Int]>

defn Tile (cols:Int, rows:Int, dots:Seqable<False|Int>) :
   val dot-seq = to-seq(dots)
   val dot-tuple = to-tuple $
      for r in (rows - 1) through 0 by -1 seq-cat :
         for c in 0 to cols seq? :
            match(next(dot-seq)) :
               (dot:Int) : One([r, c, dot])
               (dot:False) : None()
   new Tile :
      defmethod cols (this) : cols
      defmethod rows (this) : rows
      defmethod dots (this) : dot-tuple

defn rotate (t:Tile) :
   new Tile :
      defmethod cols (this) : rows(t)
      defmethod rows (this) : cols(t)
      defmethod dots (this) :
         new Collection<[Int, Int, Int]> :
            defmethod to-seq (this) :
               for [r, c, color] in dots(t) seq :
                  [c, rows(t) - r - 1, color]

val ALL-TILES = let :
   val _ = false
   [
      ;I Tile
      Tile(4, 4,
         [_ _ 0 _
          _ _ 0 _
          _ _ 0 _
          _ _ 0 _])

      ;J Tile
      Tile(3, 3,
         [_ 1 _
          _ 1 _
          1 1 _])

      ;L Tile
      Tile(3, 3,
         [_ 2 _
          _ 2 _
          _ 2 2])

      ;O Tile
      Tile(2, 2,
         [3 3
          3 3])

      ;S Tile
      Tile(3, 3,
         [_ 4 4
          4 4 _
          _ _ _])

      ;Z Tile
      Tile(3, 3,
         [6 6 _
          _ 6 6
          _ _ _])

      ;T Tile
      Tile(3, 3,
         [_ 5 _
          5 5 5
          _ _ _])
   ]

defn random-tile () :
   val n = length(ALL-TILES)
   ALL-TILES[rand(n)]

;============================================================
;======================= Board ==============================
;============================================================

deftype Board
defmulti rows (b:Board) -> Int
defmulti cols (b:Board) -> Int
defmulti get (b:Board, r:Int, c:Int) -> False|Int
defmulti active-tile (b:Board) -> False|Tile
defmulti active-tile-pos (b:Board) -> [Int, Int]
defmulti spawn-tile (b:Board) -> False
defmulti rotate-tile (b:Board) -> False|True
defmulti slide-tile (b:Board, dr:Int, dc:Int) -> False|True
defmulti stamp-active-tile (b:Board) -> False

defn Board () :
   ;Board Stats
   val num-rows = 25
   val num-cols = 10
   val board = Array<Int|False>(num-rows * num-cols, false)
   defn board-get (r:Int, c:Int) : board[r * num-cols + c]
   defn board-set (r:Int, c:Int, color:False|Int) : board[r * num-cols + c] = color

   ;Tile Stats
   var tile:False|Tile = random-tile()
   var tile-pos:[Int, Int] = [20, 0]

   ;Stamp a tile at a location
   defn stamp (t:Tile, r:Int, c:Int) :
      for [tr, tc, color] in dots(t) do :
         val dr = r + tr
         val dc = c + tc
         fatal("Illegal Stamp") when (not in-bounds?(dr, dc)) or occupied?(dr, dc)
         board-set(dr, dc, color)   

   ;Does a tile fit in a given location?
   defn in-bounds? (r:Int, c:Int) :
      r >= 0 and c >= 0 and r < num-rows and c < num-cols
   defn occupied? (r:Int, c:Int) :
      board-get(r, c) is Int
   defn fits? (t:Tile, r:Int, c:Int) :
      for [tr, tc, _] in dots(t) all? :
         val dr = r + tr
         val dc = c + tc
         in-bounds?(dr, dc) and not occupied?(dr, dc)
   defn kick (t:Tile, r:Int, c:Int) :
      val cl = for i in 1 to cols(t) find : fits?(t, r, c - i)
      val cr = for i in 1 to cols(t) find : fits?(t, r, c + i)
      match(cl, cr) :
         (cl:False, cr:False) : false
         (cl:Int, cr:False) : (- cl)
         (cl:False, cr:Int) : cr
         (cl:Int, cr:Int) : cr when cr < cl else (- cl)

   ;Find and clear full lines
   defn clear-filled-lines () :
      defn copy-row (r1:Int, r2:Int) :
         if r1 != r2 :
            for c in 0 to num-cols do :
               board-set(r2, c, board-get(r1, c))
      defn clear-row (r:Int) :
         for c in 0 to num-cols do :
            board-set(r, c, false)
      defn filled? (r:Int) :
         all?(occupied?{r, _}, 0 to num-cols)
      val filled-rows = to-seq(0 through num-rows)
      for r in 0 to num-rows do :
         copy-row(r, next(filled-rows)) when not filled?(r)
      do(clear-row, next(filled-rows) to num-rows)         
   
   new Board :
      defmethod rows (this) : num-rows
      defmethod cols (this) : num-cols
      defmethod active-tile (this) : tile
         
      defmethod active-tile-pos (this) :
         fatal("No active tile") when tile is False
         tile-pos

      defmethod get (this, r:Int, c:Int) -> False|Int :
         fatal("Out of Bounds") when not in-bounds?(r, c)
         board-get(r, c)
         
      defmethod slide-tile (this, dr:Int, dc:Int) :
         val [tr, tc] = tile-pos
         if fits?(tile as Tile, tr + dr, tc + dc) :
            tile-pos = [tr + dr, tc + dc]
            true
            
      defmethod rotate-tile (this) :
         val [tr, tc] = tile-pos
         val rtile = rotate(tile as Tile)
         if fits?(rtile, tr, tc) :
            tile = rtile
            true
         else :
            match(kick(rtile, tr, tc)) :
               (dc:Int) :
                  tile = rtile
                  tile-pos = [tr, tc + dc]
                  true
               (dc:False) :
                  false            
            
      defmethod stamp-active-tile (this) :
         val [r, c] = tile-pos
         stamp(tile as Tile, r, c)
         tile = false
         clear-filled-lines()         
         
      defmethod spawn-tile (this) :
         fatal("Tile Exists") when tile is Tile
         tile = random-tile()
         tile-pos = [20, 3]

;============================================================
;==================== Drawer ================================
;============================================================

deftype Drawer
defmulti draw (d:Drawer, b:Board, w:QWidget) -> False

defn vis-rows (b:Board) :
   rows(b) - 5

defn Drawer () :
   ;Coordinate system
   val [bx, by] = [10, 10]
   val [dx, dy] = [24, 24]
   defn coord (b:Board, r:Int, c:Int) :
      val maxy = by + vis-rows(b) * dy
      [bx + c * dx,
       maxy - r * dy - dy]

   defn visible? (b:Board, r:Int, c:Int) :
      r >= 0 and c >= 0 and
      r < vis-rows(b) and c < cols(b)

   ;Tile Colored Brushes
   val colored-brushes = to-tuple{seq(QBrush, _)} $ [
      QColor(0, 255, 255, 255)
      QColor(0, 0, 255, 255)
      QColor(255, 165, 0, 255)
      QColor(255, 255, 0, 255)
      QColor(0, 255, 0, 255)
      QColor(139, 0, 139, 255)
      QColor(255, 0, 0, 255)]

   ;Colored Pens
   val white = QColor(255, 255, 255, 255)
   val gray = QColor(230, 230, 230, 255)
   val black = QColor(0, 0, 0, 255)
   val white-pen = QPen(white, 2)
   val black-pen = QPen(black, 2)
   val gray-brush = QBrush(gray)
   new Drawer :
      defmethod draw (this, b:Board, w:QWidget) :
         val p = QPainter(w)
         
         ;Draw Grid
         set-pen(p, white-pen)
         set-brush(p, gray-brush)
         for r in 0 to vis-rows(b) do :
            for c in 0 to cols(b) do :
               val [x, y] = coord(b, r, c)
               draw-rect(p, x, y, dx, dy)
               
         ;Draw tiles
         set-pen(p, black-pen)         
         for r in 0 to vis-rows(b) do :
            for c in 0 to cols(b) do :
               match(b[r, c]) :
                  (color:Int) :
                     val [x, y] = coord(b, r, c)
                     set-brush(p, colored-brushes[color])
                     draw-rect(p, x, y, dx, dy)
                  (color:False) : false
                  
         ;Draw active tile
         match(active-tile(b)) :
            (t:Tile) :
               val [r, c] = active-tile-pos(b)
               for [tr, tc, color] in dots(t) do :
                  if visible?(b, r + tr, c + tc) :
                     val [x, y] = coord(b, r + tr, c + tc)
                     set-brush(p, colored-brushes[color])
                     draw-rect(p, x, y, dx, dy)
            (t:False) :
               false

;============================================================
;================= Scratch ==================================
;============================================================

defn main () :
   val app = QApplication()
   val widget = QWidget()  
   val drawer = Drawer()
   val board = Board()

   ;Event Handling
   set-listener{widget, _} $
      new QWidgetListener :
         defmethod painted (this) :
            with-resources $ fn () :
               draw(drawer, board, widget)
         defmethod mouse-pressed (this, e:QMouseEvent) :
            println("Mouse pressed")
         defmethod mouse-moved (this, e:QMouseEvent) :
            println("Mouse moved (%_, %_)" % [x(e), y(e)])
         defmethod key-pressed (this, e:QKeyEvent) :
            switch {key(e) == _} :
               KEY-UP : rotate-tile(board)
               KEY-DOWN : slide-tile(board, -1, 0)
               KEY-LEFT : slide-tile(board, 0, -1)
               KEY-RIGHT : slide-tile(board, 0, 1)
               KEY-SPACE : stamp-active-tile(board)
               KEY-S : spawn-tile(board)

   ;Set Framerate Timer
   val timer = QTimer{_, 33} $ fn () :
      ;println("Tick!")
      ;slide-tile(board, -1, 0)
      update(widget)
   start(timer)

   ;Start!
   show(widget)
   exec(app)

with-resources(main)
